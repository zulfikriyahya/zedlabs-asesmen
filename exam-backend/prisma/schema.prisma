generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DATABASE_DIRECT_URL")
}

// ============================================
// MULTI-TENANT ROOT
// ============================================

model School {
  id          String   @id @default(cuid())
  name        String
  code        String   @unique
  subdomain   String   @unique
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  users       User[]
  subjects    Subject[]
  questions   Question[]
  exams       Exam[]
  sessions    ExamSession[]
  auditLogs   AuditLog[]

  @@map("schools")
}

// ============================================
// USERS & AUTH
// ============================================

model User {
  id           String    @id @default(cuid())
  schoolId     String
  email        String
  username     String
  passwordHash String
  role         UserRole
  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  school         School          @relation(fields: [schoolId], references: [id])
  refreshTokens  RefreshToken[]
  devices        UserDevice[]
  attempts       ExamAttempt[]
  activityLogs   ExamActivityLog[]
  gradedAnswers  ExamAnswer[]    @relation("GradedBy")
  auditLogs      AuditLog[]

  @@unique([schoolId, email])
  @@unique([schoolId, username])
  @@index([schoolId])
  @@map("users")
}

model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  revokedAt DateTime?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("refresh_tokens")
}

model UserDevice {
  id          String    @id @default(cuid())
  userId      String
  fingerprint String
  label       String?
  isLocked    Boolean   @default(false)
  lockedAt    DateTime?
  lastSeenAt  DateTime  @default(now())
  createdAt   DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, fingerprint])
  @@index([userId])
  @@map("user_devices")
}

// ============================================
// QUESTION BANK
// ============================================

model Subject {
  id        String   @id @default(cuid())
  schoolId  String
  name      String
  code      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  school    School     @relation(fields: [schoolId], references: [id])
  questions Question[]

  @@unique([schoolId, code])
  @@index([schoolId])
  @@map("subjects")
}

model QuestionTag {
  id        String   @id @default(cuid())
  schoolId  String
  name      String
  createdAt DateTime @default(now())

  questions QuestionTagMapping[]

  @@unique([schoolId, name])
  @@map("question_tags")
}

model Question {
  id           String       @id @default(cuid())
  schoolId     String
  subjectId    String
  type         QuestionType
  content      Json         // { text, images, audio, video }
  options      Json?        // untuk tipe pilihan ganda & menjodohkan
  correctAnswer Json        // terenkripsi di level aplikasi
  points       Int          @default(1)
  difficulty   Int          @default(1) // 1-5
  status       String       @default("draft") // draft | review | approved
  createdById  String?
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  school       School               @relation(fields: [schoolId], references: [id])
  subject      Subject              @relation(fields: [subjectId], references: [id])
  tags         QuestionTagMapping[]
  examQuestions ExamQuestion[]

  @@index([schoolId])
  @@index([schoolId, subjectId])
  @@map("questions")
}

model QuestionTagMapping {
  questionId String
  tagId      String

  question Question    @relation(fields: [questionId], references: [id], onDelete: Cascade)
  tag      QuestionTag @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([questionId, tagId])
  @@map("question_tag_mappings")
}

// ============================================
// EXAMS
// ============================================

model Exam {
  id          String     @id @default(cuid())
  schoolId    String
  title       String
  description String?
  subjectId   String?
  settings    Json       // { duration, shuffleQuestions, shuffleOptions, showResult, maxAttempts, ... }
  status      ExamStatus @default(DRAFT)
  publishedAt DateTime?
  createdById String?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  school    School          @relation(fields: [schoolId], references: [id])
  questions ExamQuestion[]
  sessions  ExamSession[]

  @@index([schoolId])
  @@map("exams")
}

model ExamQuestion {
  id         String @id @default(cuid())
  examId     String
  questionId String
  order      Int
  points     Int?   // override points dari question

  exam     Exam     @relation(fields: [examId], references: [id], onDelete: Cascade)
  question Question @relation(fields: [questionId], references: [id])

  @@unique([examId, questionId])
  @@unique([examId, order])
  @@map("exam_questions")
}

// ============================================
// SESSIONS & ROOMS
// ============================================

model ExamRoom {
  id        String   @id @default(cuid())
  schoolId  String
  name      String
  capacity  Int?
  createdAt DateTime @default(now())

  sessions ExamSession[]

  @@index([schoolId])
  @@map("exam_rooms")
}

model ExamSession {
  id          String        @id @default(cuid())
  schoolId    String
  examId      String
  roomId      String?
  title       String
  startTime   DateTime
  endTime     DateTime
  status      SessionStatus @default(SCHEDULED)
  createdById String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  school   School        @relation(fields: [schoolId], references: [id])
  exam     Exam          @relation(fields: [examId], references: [id])
  room     ExamRoom?     @relation(fields: [roomId], references: [id])
  students SessionStudent[]
  attempts ExamAttempt[]

  @@index([schoolId])
  @@index([schoolId, examId])
  @@map("exam_sessions")
}

model SessionStudent {
  sessionId String
  userId    String
  tokenCode String  @unique // token unik per peserta per sesi
  addedAt   DateTime @default(now())

  session ExamSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@id([sessionId, userId])
  @@map("session_students")
}

// ============================================
// ATTEMPTS & ANSWERS
// ============================================

model ExamAttempt {
  id              String        @id @default(cuid())
  sessionId       String
  userId          String
  idempotencyKey  String        @unique // prevent duplicate submission
  deviceFingerprint String?
  startedAt       DateTime      @default(now())
  submittedAt     DateTime?
  status          AttemptStatus @default(IN_PROGRESS)
  packageHash     String?       // checksum paket soal yang diunduh
  totalScore      Float?
  maxScore        Float?
  gradingStatus   GradingStatus @default(PENDING)
  gradingCompletedAt DateTime?

  session  ExamSession  @relation(fields: [sessionId], references: [id])
  user     User         @relation(fields: [userId], references: [id])
  answers  ExamAnswer[]
  activityLogs ExamActivityLog[]
  syncItems    SyncQueue[]

  @@unique([sessionId, userId])
  @@index([sessionId])
  @@index([userId])
  @@map("exam_attempts")
}

model ExamAnswer {
  id              String   @id @default(cuid())
  attemptId       String
  questionId      String
  idempotencyKey  String   @unique
  answer          Json     // jawaban terenkripsi
  mediaUrls       String[] // presigned MinIO paths
  score           Float?
  maxScore        Float?
  feedback        String?
  isAutoGraded    Boolean  @default(false)
  gradedById      String?
  gradedAt        DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  attempt  ExamAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  gradedBy User?       @relation("GradedBy", fields: [gradedById], references: [id])

  @@unique([attemptId, questionId])
  @@index([attemptId])
  @@map("exam_answers")
}

// ============================================
// SYNC QUEUE
// ============================================

model SyncQueue {
  id             String     @id @default(cuid())
  attemptId      String
  idempotencyKey String     @unique
  type           SyncType
  payload        Json
  status         SyncStatus @default(PENDING)
  retryCount     Int        @default(0)
  maxRetries     Int        @default(5)
  lastError      String?
  processedAt    DateTime?
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt

  attempt ExamAttempt @relation(fields: [attemptId], references: [id])

  @@index([status, retryCount])
  @@index([attemptId])
  @@map("sync_queue")
}

// ============================================
// LOGGING & AUDIT
// ============================================

model ExamActivityLog {
  id        String   @id @default(cuid())
  attemptId String
  userId    String
  type      String   // tab_blur | tab_focus | copy_paste | idle | ...
  metadata  Json?
  createdAt DateTime @default(now())

  attempt ExamAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  user    User        @relation(fields: [userId], references: [id])

  @@index([attemptId])
  @@map("exam_activity_logs")
}

model AuditLog {
  id         String   @id @default(cuid())
  schoolId   String
  userId     String?
  action     String   // START_EXAM | SUBMIT_EXAM | CHANGE_SCORE | ADMIN_ACCESS | ...
  entityType String
  entityId   String
  before     Json?
  after      Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())

  school School @relation(fields: [schoolId], references: [id])
  user   User?  @relation(fields: [userId], references: [id])

  @@index([schoolId])
  @@index([schoolId, action])
  @@map("audit_logs")
}

// ============================================
// NOTIFICATIONS
// ============================================

model Notification {
  id        String   @id @default(cuid())
  userId    String
  title     String
  body      String
  type      String
  isRead    Boolean  @default(false)
  metadata  Json?
  createdAt DateTime @default(now())

  @@index([userId, isRead])
  @@map("notifications")
}

// ============================================
// ENUMS
// ============================================

enum UserRole {
  SUPERADMIN
  ADMIN
  TEACHER
  SUPERVISOR
  OPERATOR
  STUDENT
}

enum QuestionType {
  MULTIPLE_CHOICE
  COMPLEX_MULTIPLE_CHOICE
  TRUE_FALSE
  MATCHING
  SHORT_ANSWER
  ESSAY
}

enum ExamStatus {
  DRAFT
  REVIEW
  PUBLISHED
  ARCHIVED
}

enum SessionStatus {
  SCHEDULED
  ACTIVE
  PAUSED
  COMPLETED
  CANCELLED
}

enum AttemptStatus {
  IN_PROGRESS
  SUBMITTED
  TIMED_OUT
  ABANDONED
}

enum GradingStatus {
  PENDING
  AUTO_GRADED
  MANUAL_REQUIRED
  COMPLETED
  PUBLISHED
}

enum SyncStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  DEAD_LETTER
}

enum SyncType {
  SUBMIT_ANSWER
  SUBMIT_EXAM
  UPLOAD_MEDIA
  ACTIVITY_LOG
}
