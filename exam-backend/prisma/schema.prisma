generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DATABASE_DIRECT_URL")
}

// ============================================
// MULTI-TENANT ROOT
// ============================================

model Tenant {
  id        String   @id @default(cuid())
  name      String
  code      String   @unique
  subdomain String   @unique
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users        User[]
  subjects     Subject[]
  questions    Question[]
  examPackages ExamPackage[]
  sessions     ExamSession[]
  auditLogs    AuditLog[]

  @@map("tenants")
}

// ============================================
// USERS & AUTH
// ============================================

model User {
  id           String   @id @default(cuid())
  tenantId     String
  email        String
  username     String
  passwordHash String
  role         UserRole
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  tenant        Tenant            @relation(fields: [tenantId], references: [id])
  refreshTokens RefreshToken[]
  devices       UserDevice[]
  attempts      ExamAttempt[]
  activityLogs  ExamActivityLog[]
  gradedAnswers ExamAnswer[]      @relation("GradedBy")
  auditLogs     AuditLog[]
  notifications Notification[]

  @@unique([tenantId, email])
  @@unique([tenantId, username])
  @@index([tenantId])
  @@map("users")
}

model RefreshToken {
  id        String    @id @default(cuid())
  userId    String
  token     String    @unique
  expiresAt DateTime
  revokedAt DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("refresh_tokens")
}

model UserDevice {
  id          String    @id @default(cuid())
  userId      String
  fingerprint String
  label       String?
  isLocked    Boolean   @default(false)
  lockedAt    DateTime?
  lastSeenAt  DateTime  @default(now())
  createdAt   DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, fingerprint])
  @@index([userId])
  @@map("user_devices")
}

// ============================================
// QUESTION BANK
// ============================================

model Subject {
  id        String   @id @default(cuid())
  tenantId  String
  name      String
  code      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant    Tenant     @relation(fields: [tenantId], references: [id])
  questions Question[]

  @@unique([tenantId, code])
  @@index([tenantId])
  @@map("subjects")
}

model QuestionTag {
  id       String @id @default(cuid())
  tenantId String
  name     String

  questions QuestionTagMapping[]

  @@unique([tenantId, name])
  @@map("question_tags")
}

model Question {
  id            String       @id @default(cuid())
  tenantId      String
  subjectId     String
  type          QuestionType
  content       Json         // { text, images, audio, video }
  options       Json?        // untuk tipe pilihan ganda & menjodohkan
  correctAnswer Json         // terenkripsi di level aplikasi
  points        Int          @default(1)
  difficulty    Int          @default(1) // 1–5
  status        String       @default("draft") // draft | review | approved
  createdById   String?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  tenant           Tenant               @relation(fields: [tenantId], references: [id])
  subject          Subject              @relation(fields: [subjectId], references: [id])
  tags             QuestionTagMapping[]
  examPackageItems ExamPackageQuestion[]
  answers          ExamAnswer[]         // ← FK eksplisit ke jawaban siswa

  @@index([tenantId])
  @@index([tenantId, subjectId])
  @@map("questions")
}

model QuestionTagMapping {
  questionId String
  tagId      String

  question Question    @relation(fields: [questionId], references: [id], onDelete: Cascade)
  tag      QuestionTag @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([questionId, tagId])
  @@map("question_tag_mappings")
}

// ============================================
// EXAM PACKAGES
// ============================================

model ExamPackage {
  id          String            @id @default(cuid())
  tenantId    String
  title       String
  description String?
  subjectId   String?
  settings    Json              // { duration, shuffleQuestions, shuffleOptions, showResult, maxAttempts }
  status      ExamPackageStatus @default(DRAFT)
  publishedAt DateTime?
  createdById String?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  tenant    Tenant               @relation(fields: [tenantId], references: [id])
  questions ExamPackageQuestion[]
  sessions  ExamSession[]

  @@index([tenantId])
  @@map("exam_packages")
}

model ExamPackageQuestion {
  id            String @id @default(cuid())
  examPackageId String
  questionId    String
  order         Int
  points        Int?   // override points dari question

  examPackage ExamPackage @relation(fields: [examPackageId], references: [id], onDelete: Cascade)
  question    Question    @relation(fields: [questionId], references: [id])

  @@unique([examPackageId, questionId])
  @@unique([examPackageId, order])
  @@map("exam_package_questions")
}

// ============================================
// SESSIONS & ROOMS
// ============================================

model ExamRoom {
  id       String @id @default(cuid())
  tenantId String
  name     String
  capacity Int?

  sessions ExamSession[]

  @@index([tenantId])
  @@map("exam_rooms")
}

model ExamSession {
  id            String        @id @default(cuid())
  tenantId      String
  examPackageId String
  roomId        String?
  title         String
  startTime     DateTime
  endTime       DateTime
  status        SessionStatus @default(SCHEDULED)
  createdById   String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  tenant      Tenant          @relation(fields: [tenantId], references: [id])
  examPackage ExamPackage     @relation(fields: [examPackageId], references: [id])
  room        ExamRoom?       @relation(fields: [roomId], references: [id])
  students    SessionStudent[]
  attempts    ExamAttempt[]

  @@index([tenantId])
  @@index([tenantId, examPackageId])
  @@map("exam_sessions")
}

model SessionStudent {
  sessionId String
  userId    String
  tokenCode String    @unique
  expiresAt DateTime? // ← token expiry opsional
  addedAt   DateTime  @default(now())

  session ExamSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@id([sessionId, userId])
  @@map("session_students")
}

// ============================================
// ATTEMPTS & ANSWERS
// ============================================

model ExamAttempt {
  id                 String        @id @default(cuid())
  sessionId          String
  userId             String
  idempotencyKey     String        @unique
  deviceFingerprint  String?
  startedAt          DateTime      @default(now())
  submittedAt        DateTime?
  status             AttemptStatus @default(IN_PROGRESS)
  packageHash        String?
  totalScore         Float?
  maxScore           Float?
  gradingStatus      GradingStatus @default(PENDING)
  gradingCompletedAt DateTime?

  session      ExamSession       @relation(fields: [sessionId], references: [id])
  user         User              @relation(fields: [userId], references: [id])
  answers      ExamAnswer[]
  activityLogs ExamActivityLog[]
  syncItems    SyncQueue[]

  @@unique([sessionId, userId])
  @@index([sessionId])
  @@index([userId])
  @@map("exam_attempts")
}

model ExamAnswer {
  id             String    @id @default(cuid())
  attemptId      String
  questionId     String
  idempotencyKey String    @unique
  answer         Json
  mediaUrls      String[]
  score          Float?
  maxScore       Float?
  feedback       String?
  isAutoGraded   Boolean   @default(false)
  gradedById     String?
  gradedAt       DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  attempt  ExamAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  question Question    @relation(fields: [questionId], references: [id])       // ← FK eksplisit
  gradedBy User?       @relation("GradedBy", fields: [gradedById], references: [id])

  @@unique([attemptId, questionId])
  @@index([attemptId])
  @@index([questionId])
  @@map("exam_answers")
}

// ============================================
// SYNC QUEUE
// ============================================

model SyncQueue {
  id             String     @id @default(cuid())
  attemptId      String
  idempotencyKey String     @unique
  type           SyncType
  payload        Json
  status         SyncStatus @default(PENDING)
  retryCount     Int        @default(0)
  maxRetries     Int        @default(5)
  lastError      String?
  processedAt    DateTime?
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt

  attempt ExamAttempt @relation(fields: [attemptId], references: [id])

  @@index([status, retryCount])
  @@index([attemptId])
  @@map("sync_queue")
}

// ============================================
// LOGGING & AUDIT
// ============================================

model ExamActivityLog {
  id        String   @id @default(cuid())
  attemptId String
  userId    String
  type      String   // tab_blur | tab_focus | copy_paste | idle | ...
  metadata  Json?
  createdAt DateTime @default(now())

  attempt ExamAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  user    User        @relation(fields: [userId], references: [id])

  @@index([attemptId])
  @@map("exam_activity_logs")
}

model AuditLog {
  id         String   @id @default(cuid())
  tenantId   String
  userId     String?
  action     String
  entityType String
  entityId   String
  before     Json?
  after      Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id])
  user   User?  @relation(fields: [userId], references: [id])

  @@index([tenantId])
  @@index([tenantId, action])
  @@map("audit_logs")
}

// ============================================
// NOTIFICATIONS
// ============================================

model Notification {
  id        String   @id @default(cuid())
  userId    String
  title     String
  body      String
  type      String
  isRead    Boolean  @default(false)
  metadata  Json?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade) // ← relasi eksplisit

  @@index([userId, isRead])
  @@map("notifications")
}

// ============================================
// ENUMS
// ============================================

enum UserRole {
  SUPERADMIN
  ADMIN
  TEACHER
  SUPERVISOR
  OPERATOR
  STUDENT
}

enum QuestionType {
  MULTIPLE_CHOICE
  COMPLEX_MULTIPLE_CHOICE
  TRUE_FALSE
  MATCHING
  SHORT_ANSWER
  ESSAY
}

enum ExamPackageStatus {
  DRAFT
  REVIEW
  PUBLISHED
  ARCHIVED
}

enum SessionStatus {
  SCHEDULED
  ACTIVE
  PAUSED
  COMPLETED
  CANCELLED
}

enum AttemptStatus {
  IN_PROGRESS
  SUBMITTED
  TIMED_OUT
  ABANDONED
}

enum GradingStatus {
  PENDING
  AUTO_GRADED
  MANUAL_REQUIRED
  COMPLETED
  PUBLISHED
}

enum SyncStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  DEAD_LETTER
}

enum SyncType {
  SUBMIT_ANSWER
  SUBMIT_EXAM
  UPLOAD_MEDIA
  ACTIVITY_LOG
}
